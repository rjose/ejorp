(ns ejorp.reports.loading
  (:use ejorp.nouns.project, ejorp.nouns.team, ejorp.nouns.person)
  (:require [ejorp.util.density-integrals :as density])
  (:require [ejorp.protocols.workable :as workable])
  (:use clojure.set))

;; ## Load Computation
;; These functions compute the loading of a project over time. They use "density functions"
;; to estimate the required effort profile.

;;; `project-role-loading` computes the loading trajectory for a single role
;;; for a given project. It's essentially a building block for `project-loading`.
;(defn project-role-loading
;  "Returns the loading for a role over a seq of date ranges"
;  [proj role date-ranges]
;  ; We'll default to uniform density for now, but this should come from the role
;  (let [density-f density/uniform-density-integral
;        total-role-loading ((:est-load proj) role)
;        date-ranges-as-fractions (for [r date-ranges]  (map (partial workable/fraction-of proj) r))
;        normalized-values (for [r date-ranges-as-fractions] (density-f r))]
;    (map #(* total-role-loading %) normalized-values)))
;
;
;;; This computes a map of roles to loading trajectories for a given project. 
;(defn project-loading
;  "Returns the loading of a project by role over a seq of date-ranges."
;  [proj date-ranges]
;  (let [roles (project-roles proj)        
;        role-loading (for [r roles] (project-role-loading proj r date-ranges))]
;    (zipmap roles role-loading)))
;
;
;;; This is the parallel version of `project-loading`. It was basically written as a proof
;;; of concept for converting an existing function to a parallelized version.
;(defn p-project-loading
;  "This is the parallelized version of project-loading."
;  [proj date-ranges]
;  (let [roles (project-roles proj)
;        working-agents (for [r roles] (send (agent proj) project-role-loading r date-ranges))]
;    (apply await-for 5000 working-agents)
;    (zipmap roles (map deref working-agents))))
;
;
;;; ## Resource Availability
;;; These functions are used for computing the net resource availability for a team with respect to 
;;; different types of load.
;
;;; This takes a team and a loading map as might be generated by `project-loading` and figures out
;;; what the net resource availability is.
;(defn resource-availability
;  "Computes the net resource availability for a team against a loading trajectory"
;  [team loadings]
;  (let [team-resources (primary-roles team)
;        roles (union (set (keys team-resources)) (set (mapcat keys loadings)))
;        resources (merge (zipmap roles (repeat 0)) team-resources)
;        total-loading (apply merge-with #(map + %1 %2) loadings)
;        net-resources (merge-with (fn [resource loading-seq] (map #(- resource %) loading-seq)) resources total-loading)]
;    (into {} 
;          (for [[k v] net-resources]
;            (if (seq? v)
;              [k v]
;              [k (take (count (first loadings)) (repeat v))])))))
